<!doctype html><html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>基于redsocks2和pf的macOS透明代理</title><meta name=generator content="Hugo 0.112.3"><link rel=stylesheet href="https://zenuo.github.io/css/styles.min.da6e1927bcb6a0faebcb06ab9925c87524b8057860afacf48eab54fcbf9eef18.css" integrity="sha256-2m4ZJ7y2oPrrywarmSXIdSS4BXhgr6z0jqtU/L+e7xg="><script async defer data-domain=kaiwern.com src=https://plausible.io/js/plausible.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Lora&family=Source+Sans+Pro:wght@400;600&display=swap" rel=stylesheet><body class="flex flex-col min-h-screen px-6 max-w-prose md:w-2/3 m-auto"><nav class=mt-8><ul id=nav-menu class="w-full flex items-center list-reset"><li><a href=https://zenuo.github.io/>Home</a></li><li><a href=https://zenuo.github.io/fragments/>Fragments</a></li><li><a href=https://zenuo.github.io/about/>About</a></li><li><a href=https://zenuo.github.io/tags/>Tags</a></li></ul></nav><main class="flex-1 mt-10 sm:mt-12"><div><header class="mb-8 font-sans-serif"><div class="text-sm font-gray-700 mb-8"><p class="uppercase font-semibold"><a class=text-gray-700 href=/fragments>fragments</a></p><p>Sep 04, 2022</p></div><h1 class="text-3xl mb-1 font-semibold">基于redsocks2和pf的macOS透明代理</h1><p class="italic text-xs">Last updated at: Sep 04, 2022</p></header><article class="prose serif mb-16 text-gray-800"><p>坑点：在[🧰EasyConnect in Dokcer](../2021-05-01-🧰EasyConnect in Dokcer/)中记录了在容器中运行Sangfor EasyConnect的步骤，并通过socks5代理来实现VPN使用，但这种方式具有一些局限性，仅对支持了socks5或http代理的程序有用。举一个不支持的例子：我在本地执行Java工程的单元测试时，单元测试中有访问zk的逻辑，尽管在JVM参数中添加了<code>-DsocksProxySet=true -DsocksProxyHost=alpine -DsocksProxyPort=1080</code>，但对访问zk底层的nio来说是无效的😢</p><p>还好在搜索到了这两篇文章，发现可以通过透明代理来支持这种场景：</p><ul><li><a href=https://luckypoem.blog.fc2.com/blog-entry-738.html>macos使用redsocks做透明代理</a></li><li><a href=https://penglei.github.io/post/transparent_proxy_on_macosx/#_a_%E9%85%8D%E7%BD%AEpf_conf>macOS 透明代理配置</a></li></ul><p>下面是我的操作步骤</p><h1 id=1-编译配置redsocks>1 编译、配置redsocks</h1><pre tabindex=0><code>$ wget https://github.com/HaoH/redsocks/archive/release-0.68.tar.gz # 下载源码
$ tar -zxvf redsocks-release-0.68.tar.gz # 解压缩
$ cd redsocks-release-0.68
</code></pre><p>在我的电脑环境中，按照源码包的代码构建的结果，运行时会报错：</p><pre tabindex=0><code>1662282301.374137 err redsocks.c:693 redsocks_connect_relay(...) [192.168.0.103:54303-&gt;10.100.*.*:80]: red_connect_relay failed!!!: Protocol not available
1662282301.375292 err utils.c:154 red_prepare_relay(...) setsockopt: Protocol not available
</code></pre><p>可以看到报错在<code>utils.c:154</code>，经查阅<a href="https://git.kernel.dk/cgit/fio/commit/?id=8a768c2e725d6a527b904570949f6099c3f1434a">资料</a>，此种报错可以被忽略，所以修改代码：</p><pre tabindex=0><code>$ vim utils.c
</code></pre><p>将153至156行注释，忽略setsocketopt的报错：</p><pre tabindex=0><code>        // if (error) {
        //     log_errno(LOG_ERR, &#34;setsockopt&#34;);
        //     goto fail;
        // }
</code></pre><pre tabindex=0><code>$ https_proxy=socks5://localhost:1080 make OSX_VERSION=master DISABLE_SHADOWSOCKS=true # 构建
$ vim redsocks.conf
</code></pre><p>内容如下：</p><pre tabindex=0><code>base {
	log_debug = off;
	log_info = on;
	log = stderr;
	daemon = off;
	redirector = pf;
	reuseport = off;
}

redsocks {
    // redsocks的监听的地址和端口
	bind = &#34;127.0.0.1:12345&#34;;
    // 代理的地址和端口
	relay = &#34;192.168.17.128:1080&#34;;
	type = socks5;
	autoproxy = 0;
	timeout = 10;
}
</code></pre><h1 id=2-配置pf>2 配置pf</h1><p>首先我们需要定义出需要转发到代理的cidr表，存放到文件<code>/opt/app/redsocks/forward_cidr.txt</code>，若需要转发<code>10.100.0.0/16</code>和<code>10.1.0.0/16</code>网段的IP到代理，内容如下：</p><pre tabindex=0><code>10.100.0.0/16
10.1.0.0/16
</code></pre><p>编辑<code>/etc/pf.conf</code>，内容如下：</p><pre tabindex=0><code>scrub-anchor &#34;com.apple/*&#34;

table &lt;forward_cidr&gt; persist file &#34;/opt/app/redsocks/forward_cidr.txt&#34;

nat-anchor &#34;com.apple/*&#34;

rdr-anchor &#34;com.apple/*&#34;
rdr pass on lo0 proto tcp from any to &lt;forward_cidr&gt; -&gt; 127.0.0.1 port 12345

pass out route-to (lo0 127.0.0.1) proto tcp from any to &lt;forward_cidr&gt;

dummynet-anchor &#34;com.apple/*&#34;

anchor &#34;com.apple/*&#34;
load anchor &#34;com.apple&#34; from &#34;/etc/pf.anchors/com.apple&#34;
</code></pre><h2 id=3-运行>3 运行</h2><p>启动的脚本内容如下：</p><pre tabindex=0><code># 启动pf
sudo sysctl -w net.inet.ip.forwarding=1
sudo pfctl -e
sudo pfctl -F all
sudo pfctl -f /etc/pf.conf

# 启动redsocks
sudo ./redsocks2 -c ./redsocks.conf
</code></pre><p>使用代理完成之后，你可以Ctrl+C关闭redsocks，然后用下面的脚本关闭pf:</p><pre tabindex=0><code># 关闭pf
sudo pfctl -d
sudo pfctl -F all
</code></pre><div class="float-right mb-8"><p class="text-sm mb-4 font-gray-700 italic">(206 words)</p></div></article></div></main><hr><footer class="w-full text-center p-4 pin-b text-xs text-gray-400"><p>made with <a href=https://gohugo.io class="underline hover:text-blue-400">Hugo</a> and <a href=https://tailwindcss.com class="underline hover:text-blue-400">TailwindCSS</a></p></footer></body></html>