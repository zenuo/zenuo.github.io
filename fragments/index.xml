<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Fragments on</title><link>https://zenuo.github.io/fragments/</link><description>Recent content in Fragments on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 04 Sep 2022 19:23:13 +0800</lastBuildDate><atom:link href="https://zenuo.github.io/fragments/index.xml" rel="self" type="application/rss+xml"/><item><title>基于redsocks2和pf的macOS透明代理</title><link>https://zenuo.github.io/fragments/2022-09-04-%E5%9F%BA%E4%BA%8Eredsocks2%E5%92%8Cpf%E7%9A%84macos%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/</link><pubDate>Sun, 04 Sep 2022 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2022-09-04-%E5%9F%BA%E4%BA%8Eredsocks2%E5%92%8Cpf%E7%9A%84macos%E9%80%8F%E6%98%8E%E4%BB%A3%E7%90%86/</guid><description>坑点：在[🧰EasyConnect in Dokcer](../2021-05-01-🧰EasyConnect in Dokcer/)中记录了在容器中运行Sangfor EasyConnect的步骤，并通过socks5代理来实现VPN使用，但这种方式具有一些局限性，仅对支持了socks5或http代理的程序有用。举一个不支持的例子：我在本地执行Java工程的单元测试时，单元测试中有访问zk的逻辑，尽管在JVM参数中添加了-DsocksProxySet=true -DsocksProxyHost=alpine -DsocksProxyPort=1080，但对访问zk底层的nio来说是无效的😢
还好在搜索到了这两篇文章，发现可以通过透明代理来支持这种场景：
macos使用redsocks做透明代理 macOS 透明代理配置 下面是我的操作步骤
1 编译、配置redsocks $ wget https://github.com/HaoH/redsocks/archive/release-0.68.tar.gz # 下载源码 $ tar -zxvf redsocks-release-0.68.tar.gz # 解压缩 $ cd redsocks-release-0.68 在我的电脑环境中，按照源码包的代码构建的结果，运行时会报错：
1662282301.374137 err redsocks.c:693 redsocks_connect_relay(...) [192.168.0.103:54303-&amp;gt;10.100.*.*:80]: red_connect_relay failed!!!: Protocol not available 1662282301.375292 err utils.c:154 red_prepare_relay(...) setsockopt: Protocol not available 可以看到报错在utils.</description></item><item><title>使用Javac日志分析工程依赖</title><link>https://zenuo.github.io/fragments/2022-07-02-%E4%BD%BF%E7%94%A8javac%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96/</link><pubDate>Sat, 02 Jul 2022 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2022-07-02-%E4%BD%BF%E7%94%A8javac%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E5%B7%A5%E7%A8%8B%E4%BE%9D%E8%B5%96/</guid><description>最近的工作是迁移一个历史遗留的工件（本文称之为工件A），首先需要梳理这个工件的消费者。初步计划按照下面步骤进行：
在代码搜索引擎（例如zoekt）里搜索： 关键词：工件A的java文件头部的import包名 文件类型：java 然后将所有结果的工程名进行排重，得到工件A的所有消费者工程。 Q:为什么不能直接搜索pom.xml文件中搜索工件A的名称呢？
A:因为存在工件A的消费者工件传递依赖工件A的情况，此种方法不能覆盖传递依赖的场景🥹
使用Intellij IDEA打开每个消费者工程，依次查看工件A中的服务接口（interface）的使用，菜单Navigatie&amp;gt;Declaration or Usages 记录工件A的服务接口存在被使用的方法（后续实现对应的替换接口） 🤨不过看第2、3个步骤看起来挺花时间的，还有其他办法吗？
目前想到的其他办法就是从编译器日志下手，查得可以使用-verbose选项，来实现：
Uses verbose output, which includes information about each class loaded and each source file compiled.
下面通过一个demo来演示：
使用maven创建工件A：
➜ mvn archetype:generate \ -DarchetypeGroupId=org.apache.maven.archetypes \ -DarchetypeArtifactId=maven-archetype-quickstart \ -DarchetypeVersion=RELEASE \ -DgroupId=demo.</description></item><item><title>MySQL源码初探</title><link>https://zenuo.github.io/fragments/2022-04-25-mysql%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</link><pubDate>Mon, 25 Apr 2022 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2022-04-25-mysql%E6%BA%90%E7%A0%81%E5%88%9D%E6%8E%A2/</guid><description>首先需要本地编译，启用debug：
curl -o mysql-server-8.0.zip https://codeload.github.com/mysql/mysql-server/zip/refs/heads/8.0 mkdir /opt/source/mysql-server-8.0 unzip -d /opt/source/mysql-server-8.0 mysql-server-8.0.zip cd /opt/source/mysql-server-8.0/ mkdir bld cd bld cmake -DWITH_DEBUG=ON -DWITH_BOOST=/opt/source/boost_1_73_0 -DWITH_SSL=/usr/local/Cellar/openssl@1.1/1.1.1k/ -DADD_GDB_INDEX=ON -DCMAKE_BUILD_TYPE=Debug -DWITH_ARCHIVE_STORAGE_ENGINE=0 -DWITH_FEDERATED_STORAGE_ENGINE=0 -DSYSCONFDIR=/opt/app/mysql8/ .. make mysqld.exe!Per_thread_connection_handler::add_connection(Channel_info * channel_info) Line 394 at D:\opt\source\mysql-server\sql\conn_handler\connection_handler_per_thread.cc(394) mysqld.exe!Connection_handler_manager::process_new_connection(Channel_info * channel_info) Line 259 at D:\opt\source\mysql-server\sql\conn_handler\connection_handler_manager.cc(259) mysqld.exe!Connection_acceptor&amp;lt;Mysqld_socket_listener&amp;gt;::connection_event_loop() Line 66 at D:\opt\source\mysql-server\sql\conn_handler\connection_acceptor.h(66) mysqld.exe!socket_conn_event_handler(void * arg) Line 3228 at D:\opt\source\mysql-server\sql\mysqld.</description></item><item><title>在macOS上使用VS Code阅读OpenJDK源码</title><link>https://zenuo.github.io/fragments/2021-09-25-%E5%9C%A8macos%E4%B8%8A%E4%BD%BF%E7%94%A8vs-code%E9%98%85%E8%AF%BBopenjdk%E6%BA%90%E7%A0%81/</link><pubDate>Sat, 25 Sep 2021 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2021-09-25-%E5%9C%A8macos%E4%B8%8A%E4%BD%BF%E7%94%A8vs-code%E9%98%85%E8%AF%BBopenjdk%E6%BA%90%E7%A0%81/</guid><description>1 本地环境 操作系统：macOS Big Sur 11.5.2 XCode: 13A5155e JDK: openjdk version &amp;ldquo;11.0.9&amp;rdquo; VS Code: 1.60.2 2 下载OpenJDK工程 创建一个不含用户名相关（建议）的路径，例如/opt/source，将OpenJDK 11的工程克隆至本地：
cd /opt/source 将openjdk/jdk11u克隆到本地，🐢需要良好的网络环境，所以使用本地的代理；若不需要代理请忽略第一行：
https_proxy=socks5://localhost:1080 \ git clone https://github.com/openjdk/jdk11u.git ☕️建议喝杯水等会儿，等克隆完进入下个步骤。
3 为构建做配置 对于文件数量大、结构复杂的工程，一般会引入构建工具，来实现日常的开发、发布流程的标准化，如GNU Make、Apache Maven等，OpenJDK 11亦然。
对于开发阶段，要求构建耗时短（不进行程度高的优化）、构建结果便于调试（debug）、运行速度可以不那么快；对于发布阶段，要求可执行文件运行速度快，构建耗时可以稍微长点儿。OpenJDK的构建支持通过配置（configure脚本）参数--with-debug-level=&amp;lt;level&amp;gt;来指定构建结果的调试级别，来实现不同阶段对构建结果的debug支持程度。
由于本文介绍的是搭建阅读代码环境，所以是开发阶段，执行：
cd /opt/source/jdk11u bash ./configure \ #指定本地的JDK，对版本有要求 \ --with-boot-jdk=/opt/app/jdk-11.0.9+11/Contents/Home \ #若代码中存在编译时警告，使编译继续进行，不当做异常 \ --disable-warnings-as-errors \ #指定调试等级 \ --with-debug-level=slowdebug \ #调试符号将在构建过程中生成，它们将被保存在生成的二进制文件中。 \ --with-native-debug-symbols=internal 若本地环境满足构建需求，脚本正常结束，否则会有报错信息。</description></item><item><title>📦利用GitHub Actions自动构建TeX</title><link>https://zenuo.github.io/fragments/2021-09-02-%E5%88%A9%E7%94%A8github-actions%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAtex/</link><pubDate>Thu, 02 Sep 2021 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2021-09-02-%E5%88%A9%E7%94%A8github-actions%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BAtex/</guid><description>笔者维护的一些TeX文档（简历等）通常是在安装好TeX发行版的主机上进行编辑和构建，当无法访问这些主机的时候，该怎么操作呢？🤔
联想到GitHub的Actions功能，可以用来做CI/CD，也许有戏。通过搜索，找到了xu-cheng/latex-action，可以达到通过git push操作来触发构建，并将构建的pdf文件打包放置到Workflow的Artifacts中。
假设需要被编译的TeX文件的相对路径为resume.tex，编译器是XeLaTeX，那么可以用下面的workflow描述文件来达到目的：
name:Build LaTeX documenton:[push]jobs:build_latex:runs-on:ubuntu-lateststeps:- name:Set up Git repositoryuses:actions/checkout@v2- name:Compile LaTeX documentuses:xu-cheng/latex-action@v2with:root_file:resume.texpre_compile:&amp;#34;fc-list :lang=zh&amp;#34;latexmk_use_xelatex:true- uses:actions/upload-artifact@v2with:name:PDFpath:resume.pdf放置到仓库的.github/workflows/路径，再触发push即可。</description></item><item><title>lsof之外的查询使用指定文件的进程的方法</title><link>https://zenuo.github.io/fragments/2021-08-30-lsof%E4%B9%8B%E5%A4%96%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</link><pubDate>Mon, 30 Aug 2021 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2021-08-30-lsof%E4%B9%8B%E5%A4%96%E7%9A%84%E6%9F%A5%E8%AF%A2%E4%BD%BF%E7%94%A8%E6%8C%87%E5%AE%9A%E6%96%87%E4%BB%B6%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E6%B3%95/</guid><description>在主机上查看使用某个文件的使用情况时，可能会直接想到使用lsof，但不是所有主机都安装了该工具，这时你可以使用下面的命令:
find /proc -regex '\/proc\/[0-9]+\/fd\/.*' -type l -lname &amp;quot;*关键词*&amp;quot; -printf &amp;quot;%p -&amp;gt; %l\n&amp;quot; 2&amp;gt; /dev/null 它通过搜索类Unix系统的process information pseudo-filesystem，来达到目的
参考 proc(5) — Linux manual page Scott&amp;rsquo;s answer</description></item><item><title>📷在树莓派上访问iPhone拍摄的照片与视频</title><link>https://zenuo.github.io/fragments/2021-07-11-%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E8%AE%BF%E9%97%AEiphone%E6%8B%8D%E6%91%84%E7%9A%84%E7%85%A7%E7%89%87%E4%B8%8E%E8%A7%86%E9%A2%91/</link><pubDate>Sun, 11 Jul 2021 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2021-07-11-%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E8%AE%BF%E9%97%AEiphone%E6%8B%8D%E6%91%84%E7%9A%84%E7%85%A7%E7%89%87%E4%B8%8E%E8%A7%86%E9%A2%91/</guid><description>我的iPhone照片与视频的体积超过了免费iCloud提供的5GB，但又不喜欢（qiong）订阅iCloud的付费扩容计划，所以看看是否能将这些照片与视频备份到树莓派挂载的硬盘上。
硬件情况：
树莓派硬件：树莓派2B 树莓派软件：Arch Linux ARM iPhone硬件：iPhone 11 iPhone软件：14.6 下面是我的操作步骤：
为了安装ifuse，需要安装yay，但我的树莓派的pacman源并未收纳yay，所以参考官方文档构建后安装：
sudo pacman -S --needed git base-devel # 科学上网，避免网络不畅通导致的时间浪费 export http_proxy=socks5://127.0.0.1:1080;export https_proxy=socks5://127.0.0.1:1080;export ALL_PROXY=socks5://127.0.0.1:1080 git clone https://aur.archlinux.org/yay.git cd yay makepkg -si 安装ifuse：
yay -S ifuse 选择ifuse，而不是ifuse-git，然后会请求安装一些依赖，允许即可。编译🧬安装需要一些时间，耐心等待～
安装完成后，运行usbmuxd服务：
sudo systemctl start usbmuxd.service 若运行成功，此时使用usb连接树莓派与iPhone，iPhone上会弹窗询问是否信任该计算机，选择信任即可（这还用说？😂）
确认iPhone连接成功：</description></item><item><title>📦VirtualBox的端口转发功能</title><link>https://zenuo.github.io/fragments/2021-07-01-virtualbox%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD/</link><pubDate>Thu, 01 Jul 2021 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2021-07-01-virtualbox%E7%9A%84%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E5%8A%9F%E8%83%BD/</guid><description>在使用VirtualBox时，若需要从主机访问虚拟机，我通常的做法是添加一个host only的网络适配器，然后通过这个适配器的IP访问。
但同样的需求也可通过配置NAT适配器上的端口转发规则来实现，更加轻量化。
例如，我需要访问虚拟机的22和53124端口，配置如下，即可通过访问127.0.0.1的53124端口来访问虚拟机的53124端口，通过访问127.0.0.1的53125端口来访问虚拟机的22端口。</description></item><item><title>🧰EasyConnect in Dokcer</title><link>https://zenuo.github.io/fragments/2021-05-01-easyconnect-in-dokcer/</link><pubDate>Sat, 01 May 2021 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2021-05-01-easyconnect-in-dokcer/</guid><description>Sangfor EasyConnect是一款专有的VPN解决方案，官方支持多种平台的客户端；但该软件目前存在以下的几种行为：
配置一个开机自动启动的守护进程EasyMonitor 安装CA根证书 为了避免上述两种情况对本地系统造成不良影响，尝试寻找方法将EasyConnect运行在受控的容器内。所幸在Hagb/docker-easyconnect找到了，该仓库介绍了一种在Docker内运行EasyConnect的方案。通过该方案，在此记录下我的实践过程。
1 运行容器 在Docker宿主机为Alpine Linux时，映射到Docker宿主机的端口，无法在宿主机的外部网络（例如宿主机所在的局域网）访问，但可以在宿主机本地访问；
创建文件用于保存登录凭证，以实现auto login：
$ touch ~/.easyconn 从Docker镜像hagb/docker-easyconnect:cli创建一个名称为easyconnect的容器，并且将容器的1080端口映射到Docker宿主机的1080端口（1080只是一个示例值，可以是其他的；敲黑板，后续会用到）：
$ docker run --name easyconnect --device /dev/net/tun --cap-add NET_ADMIN -ti -v $HOME/.easyconn:/root/.easyconn -e EC_VER=7.6.8 -e EXIT=1 -p 1080:1080 hagb/docker-easyconnect:cli 根据提示输入服务器URL、用户名、密码。
注意服务器URL末尾不需要反斜线（/），例如正确的https://vpn_host。
如果成功登入，则会提示：
user &amp;quot;xx&amp;quot; login successfully! 2 浏览器over proxy 浏览器运行时动态配置代理，可以通过SwitchyOmega来实现，须将Proxy设置为Docker宿主机的1080端口</description></item><item><title>🔦如何使用GDB调试Nginx</title><link>https://zenuo.github.io/fragments/2021-02-28-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95nginx/</link><pubDate>Sun, 28 Feb 2021 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2021-02-28-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8gdb%E8%B0%83%E8%AF%95nginx/</guid><description>本文主要描述在CentOS 7下，使用gdb调试Nginx
1 准备 下载nginx及其依赖项目源码，并解压：
curl -OL https://mirrors.sohu.com/nginx/nginx-1.19.7.tar.gz tar zxf nginx-1.19.7.tar.gz curl -OL https://ftp.pcre.org/pub/pcre/pcre-8.44.tar.gz tar zxf pcre-8.44.tar.gz curl -OL http://zlib.net/zlib-1.2.11.tar.gz tar zxf zlib-1.2.11.tar.gz 安装构建工具：
yum install gcc make 构建nginx:
cd /opt/app/nginx-1.19.7 ./configure --with-debug --with-cc-opt=&amp;#39;-O0 -g&amp;#39; --with-pcre=/opt/app/pcre-8.44 --with-zlib=/opt/app/zlib-1.2.11 --prefix=/opt/app/nginx make &amp;amp;&amp;amp; make install 修改nginx配置文件/opt/app/nginx/conf/nginx.conf:
# 最好是1，便于断点调试 worker_processes 1; events { worker_connections 1024; } http { include mime.</description></item><item><title>🧰Xcode中创建Swift Package并在Target中使用</title><link>https://zenuo.github.io/fragments/2020-10-31-xcode%E4%B8%AD%E5%88%9B%E5%BB%BAswift-package%E5%B9%B6%E5%9C%A8target%E4%B8%AD%E4%BD%BF%E7%94%A8/</link><pubDate>Sat, 31 Oct 2020 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2020-10-31-xcode%E4%B8%AD%E5%88%9B%E5%BB%BAswift-package%E5%B9%B6%E5%9C%A8target%E4%B8%AD%E4%BD%BF%E7%94%A8/</guid><description>首先在Xcode上创建一个Swift Package，菜单是File / New / Swift Package：
选择保存路径：
注意选择Add to：
选择Project / TARGETS，然后选择需要使用我们刚才创建的Swift Package的Target，然后选择General栏，在Framworks, Libraries, and Embedded Content中添加Package，如图： 选择Build Phases，在Dependencies添加Package，如图： 没有其他问题的话，您的Target能成功构建了。
Reference Organizing Your Code with Local Packages Adding Package Dependencies to Your App</description></item><item><title>📝基于xeCJK的TeX中文书写</title><link>https://zenuo.github.io/fragments/2020-07-19-%E5%9F%BA%E4%BA%8Execjk%E7%9A%84tex%E4%B8%AD%E6%96%87%E4%B9%A6%E5%86%99/</link><pubDate>Sun, 19 Jul 2020 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2020-07-19-%E5%9F%BA%E4%BA%8Execjk%E7%9A%84tex%E4%B8%AD%E6%96%87%E4%B9%A6%E5%86%99/</guid><description>1 安装环境 首先，您需要在本地安装一个TeX发行版，您可以选择大而全的MacTeX，为了节省本地空间，此处选择更小的发行版BasicTeX；若网速过慢，你可以选择国内院校提供的镜像，比如tuna（清华大学开源软件镜像站）；下载完成之后，运行程序，一路continue即可：
其次，使用tlmgr(the native TeX Live Manager)安装ctex和xecjk：
$ sudo tlmgr install ctex xecjk 2 Hello World 创建一个纯文本文件hello_world.tex，内容为：
\documentclass{article} \usepackage{xeCJK} \setCJKmainfont{STSong} \begin{document} Hello World!\\ 天地玄黃宇宙洪荒日月盈仄 \end{document} 保存文件，使用xelatex命令，输出pdf文件：
$ xelatex hello_world.tex 如果不出问题的话，输出的hello_world.pdf文件将会是：
3 参考 ** Smaller Download ** 全面总结如何在 LaTeX 中使用中文 (2020 最新版) - jdhao&amp;rsquo;s blog Include Chinese characters into article in Xelatex</description></item><item><title>📜读取MySQL的binlog</title><link>https://zenuo.github.io/fragments/2020-07-12-%E8%AF%BB%E5%8F%96mysql%E7%9A%84binlog/</link><pubDate>Sun, 12 Jul 2020 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2020-07-12-%E8%AF%BB%E5%8F%96mysql%E7%9A%84binlog/</guid><description>配置~/.my.cnf，开启binlog:
[mysqld] server-id=master-01 log-bin=mysql-bin 假设需要读取的binlog的文件是mysql-bin.000001，那么用下面命令即可根据开始结束时间输出可读日志：
mysqlbinlog --base64-output=DECODE-ROWS \ -v \ --start-datetime=&amp;#39;2020-07-12 21:33:10&amp;#39; \ --stop-datetime=&amp;#39;2020-07-12 21:40:10&amp;#39; \ mysql-bin.000001 输出如下：
/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=1*/; /*!50003 SET @OLD_COMPLETION_TYPE=@@COMPLETION_TYPE,COMPLETION_TYPE=0*/; DELIMITER /*!*/; # at 4 #200712 21:24:18 server id 0 end_log_pos 123 CRC32 0x0d383a89 Start: binlog v 4, server v 5.7.29-log created 200712 21:24:18 at startup ROLLBACK/*!</description></item><item><title>🚇基于v2ray的科学上网</title><link>https://zenuo.github.io/fragments/2020-07-11-%E5%9F%BA%E4%BA%8Ev2ray%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</link><pubDate>Sat, 11 Jul 2020 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2020-07-11-%E5%9F%BA%E4%BA%8Ev2ray%E7%9A%84%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</guid><description>本篇笔记尝试从v2ray是什么、浅谈工作原理、运行服务端、运行客户端四个方面，通过少许命令和配置内容，让我们能迅速上手使用v2ray。
v2ray是什么？ Project V 是一个工具集合，它可以帮助你打造专属的基础通信网络。Project V 的核心工具称为V2Ray，其主要负责网络协议和功能的实现，与其它 Project V 通信。V2Ray 可以单独运行，也可以和其它工具配合，以提供简便的操作流程。
当然，v2ray是开源的，主要特性如下：
多入口多出口: 一个 V2Ray 进程可并发支持多个入站和出站协议，每个协议可独立工作。 可定制化路由: 入站流量可按配置由不同的出口发出。轻松实现按区域或按域名分流，以达到最优的网络性能。 多协议支持: V2Ray 可同时开启多个协议支持，包括 Socks、HTTP、Shadowsocks、VMess 等。每个协议可单独设置传输载体，比如 TCP、mKCP、WebSocket 等。 隐蔽性: V2Ray 的节点可以伪装成正常的网站（HTTPS），将其流量与正常的网页流量混淆，以避开第三方干扰。 反向代理: 通用的反向代理支持，可实现内网穿透功能。 多平台支持: 原生支持所有常见平台，如 Windows、Mac OS、Linux，并已有第三方支持移动平台。 浅谈工作原理 使用方式上，v2ray与其他代理shadowsocks工具类似，需要运行服务端和客户端两个实例(instance)。
常见的场景里，客户端运行在PC、手机等终端设备，服务端运行在云主机等服务器上。例如，我们若要在手机访问Google搜索引擎时，如果手机所在的网络禁用了Google的IP和域名，那么手机是无法直接访问的，需要由一个「手机可以访问的中间网络节点，且该节点能访问Google搜索引擎」的代理来起到一个桥梁的作用：手机的浏览器把HTTP请求发送到代理，代理把HTTP请求发送到Google搜索引擎，Google搜索引擎的HTTP响应会顺着这条路线最终返回给终端设备的浏览器。
在这里，v2ray和shadowsocks等网络工具就扮演了代理这个角色，但仅仅做网络流量代理是不够的，因为网络流量由网络协议承载，若协议的特征能被防火墙识别，被识别就意味着防火墙有理由把我们的代理IP添加到黑名单中，导致无法终端设备无法访问这个代理；所以网络工具还需要支持不易被识别的网络协议，这些协议往往不被浏览器等应用支持，需要由网络工具自己来支持，所以用作代理的网络工具需要运行客户端和服务端。
浏览器等终端应用通过HTTP、Socks5等常见的网络协议把流量发送给代理客户端，客户端再通过特定的协议将流量发送给代理服务端；
在v2ray的设计中，终端应用到代理客户端的接口被称为Inbound（入口），代理服务端到实际目的地（例如Google搜索引擎）的接口被称为Outbound（出口）。
运行服务端 摘自Project V官网，并假设你的服务端运行在Linux操作系统上。
1 下载 V2Ray 预编译的压缩包可以在如下几个站点找到：</description></item><item><title>🧶Java线程与其对应的Linux进程号</title><link>https://zenuo.github.io/fragments/2019-09-23-java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84linux%E8%BF%9B%E7%A8%8B%E5%8F%B7/</link><pubDate>Mon, 23 Sep 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-09-23-java%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84linux%E8%BF%9B%E7%A8%8B%E5%8F%B7/</guid><description>1 ps -eLf 首先，在Linux下，我们可以用ps -eLf命令看到java的线程号：
$ ps -eLf | grep java | grep -v grep opt 10801 1 10801 0 23 Sep19 ? 00:00:00 java -XX:+UseG1GC -XX:+UseStringDeduplication -Xms32m -Xmx32m -server -jar gogo.jar opt 10801 1 10806 0 23 Sep19 ? 00:00:02 java -XX:+UseG1GC -XX:+UseStringDeduplication -Xms32m -Xmx32m -server -jar gogo.jar opt 10801 1 10807 0 23 Sep19 ?</description></item><item><title>🔍如何比较两个Collection含有相同的元素——来自Apache Commons Collections的实现</title><link>https://zenuo.github.io/fragments/2019-07-20-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAcollection%E5%90%AB%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E5%85%83%E7%B4%A0%E6%9D%A5%E8%87%AAapache-commons-collections%E7%9A%84%E5%AE%9E%E7%8E%B0/</link><pubDate>Sat, 20 Jul 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-07-20-%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAcollection%E5%90%AB%E6%9C%89%E7%9B%B8%E5%90%8C%E7%9A%84%E5%85%83%E7%B4%A0%E6%9D%A5%E8%87%AAapache-commons-collections%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid><description>您可以在org.apache.commons.collections4.CollectionUtils查看源代码。
Apache Commons Collections中的CollectionUtils#isEqualCollection(java.util.Collection&amp;lt;?&amp;gt;, java.util.Collection&amp;lt;?&amp;gt;)方法（及其重载），提供了比较两个Collection含有相同的元素的实现，其源代码如下：
/** * Returns {@code true} iff the given {@link Collection}s contain * exactly the same elements with exactly the same cardinalities. * &amp;lt;p&amp;gt; * That is, iff the cardinality of &amp;lt;i&amp;gt;e&amp;lt;/i&amp;gt; in &amp;lt;i&amp;gt;a&amp;lt;/i&amp;gt; is * equal to the cardinality of &amp;lt;i&amp;gt;e&amp;lt;/i&amp;gt; in &amp;lt;i&amp;gt;b&amp;lt;/i&amp;gt;, * for each element &amp;lt;i&amp;gt;e&amp;lt;/i&amp;gt; in &amp;lt;i&amp;gt;a&amp;lt;/i&amp;gt; or &amp;lt;i&amp;gt;b&amp;lt;/i&amp;gt;.</description></item><item><title>🗜原始类型与包装类型在自增运算上的区别</title><link>https://zenuo.github.io/fragments/2019-07-02-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%9C%A8%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Tue, 02 Jul 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-07-02-%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B%E5%9C%A8%E8%87%AA%E5%A2%9E%E8%BF%90%E7%AE%97%E4%B8%8A%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>在编码时，为了实现计数，我们可能会在for循环中对原始类型或者包装类型的值（对于包装类型是实例）进行自增，那么它们两种写法的区别如何？我们可以写出如下测试代码：
private static void primitive() { int i = 0; i++; System.out.println(i); } private static void wrapper() { Integer i = 0; i++; System.out.println(i); } 截图自字节码查看工具jclasslib
primitive方法：
wrapper方法：
可以看到包装类型的自增比原始类型复杂得多，应尽量避免这种情况。</description></item><item><title>基于Wine使用QQ轻聊版</title><link>https://zenuo.github.io/fragments/2019-06-15-%E5%9F%BA%E4%BA%8Ewine%E4%BD%BF%E7%94%A8qq%E8%BD%BB%E8%81%8A%E7%89%88/</link><pubDate>Sat, 15 Jun 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-06-15-%E5%9F%BA%E4%BA%8Ewine%E4%BD%BF%E7%94%A8qq%E8%BD%BB%E8%81%8A%E7%89%88/</guid><description>wine是用于在其他操作系统上运行Windows应用程序的开源软件，我们可以用它来在Linux操作系统上使用QQ轻聊版客户端，满足日常的通信需求。当然，你还可以使用微信等客户端，操作流程与本文所述大同小异。
安装wine 执行命令：
# 安装wine和winetrick，我们用后者来安装一些依赖库 sudo pacman -S wine winetrick # 设置环境变量WINEARCH为win32 echo &amp;#34;\nexport WINEARCH=win32&amp;#34; &amp;gt;&amp;gt; ~/.profile &amp;amp;&amp;amp; source ~/.profile # 安装依赖库，此步骤需要下载一些文件，您可以设置http_proxy和https_proxy来使用代理，达到加速的目的 winetricks msxml3 gdiplus riched20 riched30 ie6 vcrun6 vcrun2005sp1 vcrun6sp6 # 追加配置到~/.wine/drive_c/windows/win.ini echo &amp;#34;\n[Desktop] menufontsize=13 messagefontsize=13 statusfontsize=13 IconTitleSize=13&amp;#34; &amp;gt;&amp;gt; ~/.wine/drive_c/windows/win.ini 创建文件font.reg：
REGEDIT4 [HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes] &amp;quot;Arial&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Arial CE,238&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Arial CYR,204&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Arial Greek,161&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Arial TUR,162&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Courier New&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Courier New CE,238&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Courier New CYR,204&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Courier New Greek,161&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Courier New TUR,162&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;FixedSys&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Helv&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Helvetica&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;MS Sans Serif&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;MS Shell Dlg&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;MS Shell Dlg 2&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;System&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Tahoma&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Times&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Times New Roman CE,238&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Times New Roman CYR,204&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Times New Roman Greek,161&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Times New Roman TUR,162&amp;quot;=&amp;quot;simsun&amp;quot; &amp;quot;Tms Rmn&amp;quot;=&amp;quot;simsun&amp;quot; 根据该文件修改注册表，执行：</description></item><item><title>MySQL随机查询一条记录</title><link>https://zenuo.github.io/fragments/2019-06-04-mysql%E9%9A%8F%E6%9C%BA%E6%9F%A5%E8%AF%A2%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95/</link><pubDate>Tue, 04 Jun 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-06-04-mysql%E9%9A%8F%E6%9C%BA%E6%9F%A5%E8%AF%A2%E4%B8%80%E6%9D%A1%E8%AE%B0%E5%BD%95/</guid><description>表结构 CREATETABLE`poet`(`id`bigint(20)unsignedNOTNULLAUTO_INCREMENT,`dynasty`varchar(11)DEFAULTNULL,`author`textDEFAULTNULL,`paragraph`textDEFAULTNULL,`strains`textDEFAULTNULL,`title`textDEFAULTNULL,PRIMARYKEY(`id`),KEY`poet_title`(`title`(10))USINGBTREE,KEY`poet_dynasty`(`dynasty`)USINGHASH,KEY`poet_author`(`author`(10))USINGBTREE)ENGINE=InnoDBAUTO_INCREMENT=311862DEFAULTCHARSET=utf8mb4;查询语句 SELECTr1.title,r1.author,r1.paragraphFROMpoetASr1JOIN(SELECTCEIL(RAND()*(SELECTMAX(id)FROMpoet))ASid)ASr2WHEREr1.id&amp;gt;=r2.idORDERBYr1.idASCLIMIT1;结果样例：
*************************** 1. row *************************** title: 雜詠下 林禽 author: 洪适 paragraph: 蒙潤碧千顆，迎曦紅半頰。閱古憩鵝池，牽連青李帖。 1 row in set (0.001 sec) 若要查询随机的一条author为李白的记录，此处使用存储过程来实现：
DELIMITER$CREATEDEFINER=`app`@`%`PROCEDURE`random_poet_of_libai`()BEGINSET@_rand_index:=CEIL(RAND()*(SELECTCOUNT(*)FROMpoetWHEREauthor=&amp;#39;李白&amp;#39;));PREPAREstmtFROM&amp;#39;SELECT title, author, paragraph FROM poet WHERE author = \&amp;#39;李白\&amp;#39; LIMIT ?, 1;&amp;#39;;EXECUTEstmtUSING@_rand_index;DEALLOCATEPREPAREstmt;ENDDELIMITER;CALLrandom_poet_of_libai();结果样例：
*************************** 1. row *************************** title: 雜曲歌辭 鳴雁行 author: 李白 paragraph: 胡雁鳴，辭燕山，昨發委羽朝度關。一一銜蘆枝，南飛散落天地間。連行接翼往復還，客居煙波寄湘吳。凌霜觸雪毛體枯，畏逢矰繳驚相呼。 1 row in set (0.008 sec) 参考 MySQL select 10 random rows from 600K rows fast Using variable in a LIMIT clause in MySQL</description></item><item><title>基于Nginx的反向代理</title><link>https://zenuo.github.io/fragments/2019-06-03-%E5%9F%BA%E4%BA%8Enginx%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link><pubDate>Mon, 03 Jun 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-06-03-%E5%9F%BA%E4%BA%8Enginx%E7%9A%84%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid><description>配置文件如下：
user www; worker_processes 1; pid logs/nginx.pid; events { worker_connections 1024; use epoll; } http { log_format main '$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; ' '$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; ' '&amp;quot;$http_user_agent&amp;quot; &amp;quot;$google&amp;quot;'; access_log logs/access.log main; access_log off; include mime.types; default_type application/octet-stream; client_max_body_size 5M; client_body_buffer_size 256K; types_hash_max_size 2048; #设定DNS resolver [2001:4860:4860::8888] [2001:4860:4860::8844]; sendfile on; tcp_nopush on; keepalive_timeout 65; gzip on; proxy_connect_timeout 5; proxy_read_timeout 60; proxy_send_timeout 5; proxy_buffer_size 16k; proxy_buffers 4 64k; proxy_busy_buffers_size 128k; #proxy_temp_file_write_size 128k; #proxy_temp_path /var/nginx_cache/temp; #设定缓存的路径和其他参数，http://nginx.</description></item><item><title>Golang的交叉编译</title><link>https://zenuo.github.io/fragments/2019-05-27-golang%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</link><pubDate>Mon, 27 May 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-05-27-golang%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/</guid><description>GOOS=${OS[$i]} \ GOARCH=${ARCH[$i]} \ go build -o $EXECUTABLE 合法的$GOOS和$GOARCH组合为：
$GOOS $GOARCH android arm darwin 386 darwin amd64 darwin arm darwin arm64 dragonfly amd64 freebsd 386 freebsd amd64 freebsd arm linux 386 linux amd64 linux arm linux arm64 linux ppc64 linux ppc64le linux mips linux mipsle linux mips64 linux mips64le linux s390x netbsd 386 netbsd amd64 netbsd arm openbsd 386 openbsd amd64 openbsd arm plan9 386 plan9 amd64 solaris amd64 windows 386 windows amd64 参考 Optional environment variables</description></item><item><title>MySQL查询数据并插入</title><link>https://zenuo.github.io/fragments/2019-05-27-mysql%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%8F%92%E5%85%A5/</link><pubDate>Mon, 27 May 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-05-27-mysql%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE%E5%B9%B6%E6%8F%92%E5%85%A5/</guid><description>查询user表中的type不为1的数据并插入employee表：
-- 查询字段列表的字符串 selectGROUP_CONCAT(COLUMN_NAMESEPARATOR&amp;#39;,&amp;#39;)from`information_schema`.`COLUMNS`WHERETABLE_NAME=&amp;#39;employee&amp;#39;;-- 查询并插入 insertintoemployee(id,mobile,school_id,school_limit,nick_name,sex,picture_url,type,active,contact_mobile,password,salt,token,old_access_token_md5,forum_vest,forum_nickname,forum_head_portrait_url,status,create_time,update_time,delete_time)selectid,mobile,school_id,school_limit,nick_name,sex,picture_url,type,active,contact_mobile,password,salt,token,old_access_token_md5,forum_vest,forum_nickname,forum_head_portrait_url,status,create_time,update_time,delete_timefromuserwheretype!</description></item><item><title>一个Shell管道的题目</title><link>https://zenuo.github.io/fragments/2019-05-17-%E4%B8%80%E4%B8%AAshell%E7%AE%A1%E9%81%93%E7%9A%84%E9%A2%98%E7%9B%AE/</link><pubDate>Fri, 17 May 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-05-17-%E4%B8%80%E4%B8%AAshell%E7%AE%A1%E9%81%93%E7%9A%84%E9%A2%98%E7%9B%AE/</guid><description>有如下a文件和b文件，请使用shell管道命令实现根据a文件中17:20~17:35期间doValidate的traceId找寻b文件中对应的日志信息：
$ cat a 2019-03-04 17:20:16 doValidate [traceId12] 2019-03-04 17:21:17 doValidate [traceId13] 2019-03-04 17:35:16 doValidate [traceId13] 2019-03-04 18:20:16 doValidate [traceId14] 2019-03-04 19:20:16 doValidate [traceId14] $ cat b 2019-03-04 17:20:17 xxxxxx2 [traceId12] 2019-03-04 17:21:18 xxxx22dd [traceId13] 2019-03-04 17:35:18 xxxx22dd [traceId13] 2019-03-04 18:20:17 xxxxed [traceId14] 2019-03-04 19:20:17 xxxsdsdfs [traceId14] 答案：
$ sed -n &amp;#39;/2019-03-04 17:20:*/,/2019-03-04 17:35:*/p&amp;#39; a|grep doValidate|awk &amp;#39;{print $4}&amp;#39;|uniq| xargs -I &amp;#39;{}&amp;#39; grep -F &amp;#39;{}&amp;#39; b 2019-03-04 17:20:17 xxxxxx2 [traceId12] 2019-03-04 17:21:18 xxxx22dd [traceId13] 2019-03-04 17:35:18 xxxx22dd [traceId13] 参考 BASH Programming - Introduction HOW-TO: Pipes Make xargs execute the command once for each line of input - Stack Overflow</description></item><item><title>MySQL中的并、差、交和除运算</title><link>https://zenuo.github.io/fragments/2019-04-26-mysql%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%B7%AE%E4%BA%A4%E5%92%8C%E9%99%A4%E8%BF%90%E7%AE%97/</link><pubDate>Fri, 26 Apr 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-04-26-mysql%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%B7%AE%E4%BA%A4%E5%92%8C%E9%99%A4%E8%BF%90%E7%AE%97/</guid><description>翻译自Union, Difference, Intersection, and Division in MySQL
构建数据库 -- 创建a和b表 CREATETABLEa(xINT,yVARCHAR(5));CREATETABLEb(xINT,yVARCHAR(5));-- 插入数据到a表 INSERTINTOa(x,y)VALUES(1,&amp;#39;A&amp;#39;);INSERTINTOa(x,y)VALUES(2,&amp;#39;B&amp;#39;);INSERTINTOa(x,y)VALUES(3,&amp;#39;C&amp;#39;);INSERTINTOa(x,y)VALUES(4,&amp;#39;D&amp;#39;);-- 插入数据到b表 INSERTINTOb(x,y)VALUES(1,&amp;#39;A&amp;#39;);INSERTINTOb(x,y)VALUES(3,&amp;#39;C&amp;#39;);SELECT*FROMa;+------+------+ |x|y|+------+------+ |1|A||2|B||3|C||4|D|+------+------+ SELECT*FROMb;+------+------+ |x|y|+------+------+ |1|A||3|C|+------+------+ 并集(Union) SELECT*FROMaUNIONSELECT*FROMb;+------+------+ |x|y|+------+------+ |1|A||2|B||3|C||4|D|+------+------+ SELECT*FROMaUNIONALLSELECT*FROMb;+------+------+ |x|y|+------+------+ |1|A||2|B||3|C||4|D||1|A||3|C|+------+------+ 差集(Difference) SELECT*FROMaWHERE(x,y)NOTIN(SELECT*FROMb);+------+------+ |x|y|+------+------+ |2|B||4|D|+------+------+ SELECT*FROMaWHERENOTEXISTS(SELECT*FROMbWHEREb.x=a.xANDb.y=a.y);+------+------+ |x|y|+------+------+ |2|B||4|D|+------+------+ -- 最高效的方式 SELECTDISTINCTa.xASx,a.yASyFROMaLEFTOUTERJOINbUSING(x,y)WHEREb.xISNULL;+------+------+ |x|y|+------+------+ |2|B||4|D|+------+------+ 交集(Intersection) SELECT*FROMaWHERE(x,y)IN(SELECT*FROMb)+------+------+ |x|y|+------+------+ |1|A||3|C|+------+------+ SELECT*FROMaWHEREEXISTS(SELECT*FROMbWHEREb.x=a.xANDb.y=a.y);+------+------+ |x|y|+------+------+ |1|A||3|C|+------+------+ -- 最高效的方式 SELECTDISTINCTa.xASx,a.yASyFROMaINNERJOINbUSING(x,y);+------+------+ |x|y|+------+------+ |1|A||3|C|+------+------+ 构建数据库 -- 创建c和d表 CREATETABLEc(xINT,yVARCHAR(5));CREATETABLEd(xINT);-- 插入数据到c表 INSERTINTOc(x,y)VALUES(1,&amp;#39;A&amp;#39;);INSERTINTOc(x,y)VALUES(2,&amp;#39;A&amp;#39;);INSERTINTOc(x,y)VALUES(3,&amp;#39;A&amp;#39;);INSERTINTOc(x,y)VALUES(1,&amp;#39;B&amp;#39;);INSERTINTOc(x,y)VALUES(2,&amp;#39;B&amp;#39;);INSERTINTOc(x,y)VALUES(3,&amp;#39;C&amp;#39;);INSERTINTOc(x,y)VALUES(3,&amp;#39;D&amp;#39;);-- 插入数据到d表 INSERTINTOd(x)VALUES(1);INSERTINTOd(x)VALUES(2);INSERTINTOd(x)VALUES(3);除法(Division) SELECTDISTINCTc1.</description></item><item><title>class-visualizer——一个查看类关系的图形化工具</title><link>https://zenuo.github.io/fragments/2019-04-19-class-visualizer%E4%B8%80%E4%B8%AA%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7/</link><pubDate>Fri, 19 Apr 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-04-19-class-visualizer%E4%B8%80%E4%B8%AA%E6%9F%A5%E7%9C%8B%E7%B1%BB%E5%85%B3%E7%B3%BB%E7%9A%84%E5%9B%BE%E5%BD%A2%E5%8C%96%E5%B7%A5%E5%85%B7/</guid><description>本人使用的IntelliJ IDEA Community Edition没有Class Diagram功能，在逛stackoverflow时，发现了工具Class Visualizer，通过加载Jar包的形式绘制类关系图表，在阅读开源项目源代码时能提供帮助，下图是io.netty.channel.Channel的关系图：
下图是其类图：
真香😋
参考：
Class diagrams - Help | IntelliJ IDEA - JetBrains Sketch It! - Plugins | JetBrains Application to generate Java class hierarchy diagram</description></item><item><title>树莓派电源最大化</title><link>https://zenuo.github.io/fragments/2019-04-19-%E6%A0%91%E8%8E%93%E6%B4%BE%E7%94%B5%E6%BA%90%E6%9C%80%E5%A4%A7%E5%8C%96/</link><pubDate>Fri, 19 Apr 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-04-19-%E6%A0%91%E8%8E%93%E6%B4%BE%E7%94%B5%E6%BA%90%E6%9C%80%E5%A4%A7%E5%8C%96/</guid><description>在将无电源的USB移动硬盘连接在树莓派上时，会发现无法正常驱动，在移动硬盘无故障的前提下是树莓派默认没有允许USB电流最大，经过谷歌🦴，找到如下解决办法：
在文件/boot/config.txt中添加：
max_usb_current=1 重启即可。
参考：
https://www.raspberrypi.org/forums/viewtopic.php?t=105502</description></item><item><title>使用tcpdump抓包</title><link>https://zenuo.github.io/fragments/2019-03-10-%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85/</link><pubDate>Sun, 10 Mar 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-03-10-%E4%BD%BF%E7%94%A8tcpdump%E6%8A%93%E5%8C%85/</guid><description>在开发网络程序时，可以使用WireShark等工具在本地抓包，但往往本地无法模拟生产环境的网络状况，所以我们有在服务器上抓包的需求；tcpdump可以胜任这个工作，首先你可以使用包管理器直接安装它，也可以自己构建，安装完成后，可以根据需求使用其过滤语法确定抓取的流量的范围，例如：在所有网络接口上抓取端口是5070的流量，并且保存到文件~/5070.pcap：
$ sudo tcpdump -nvAx -i any &amp;#39;port 5070&amp;#39; -w ~/5070.pcap 将文件拷贝到本地后，可使用WireShark打开，如图：
参考 Let&amp;rsquo;s learn tcpdump! by Julia Evans Tcpdump filters by Marios Iliofotou</description></item><item><title>MySQL测试表中是否存在行的最佳方法</title><link>https://zenuo.github.io/fragments/2019-02-22-mysql%E6%B5%8B%E8%AF%95%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%A1%8C%E7%9A%84%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95/</link><pubDate>Fri, 22 Feb 2019 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2019-02-22-mysql%E6%B5%8B%E8%AF%95%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E8%A1%8C%E7%9A%84%E6%9C%80%E4%BD%B3%E6%96%B9%E6%B3%95/</guid><description>SELECTEXISTS(SELECTidFROMfundsWHEREuser_id=#{userId}ANDschool_id=#{schoolId}LIMIT1)参考 best-way-to-test-if-a-row-exists-in-a-mysql-table</description></item><item><title>基于OpenCV的图像缩放脚本</title><link>https://zenuo.github.io/fragments/2018-10-14-%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E8%84%9A%E6%9C%AC/</link><pubDate>Sun, 14 Oct 2018 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2018-10-14-%E5%9F%BA%E4%BA%8Eopencv%E7%9A%84%E5%9B%BE%E5%83%8F%E7%BC%A9%E6%94%BE%E8%84%9A%E6%9C%AC/</guid><description>1 OpenCV是什么 摘自维基百科的OpenCV词条：
OpenCV (Open Source Computer Vision) is a library of programming functions mainly aimed at real-time computer vision. Originally developed by Intel, it was later supported by Willow Garage then Itseez (which was later acquired by Intel). The library is cross-platform and free for use under the open-source BSD license.</description></item><item><title>在树莓派上安装Arch Linux ARM</title><link>https://zenuo.github.io/fragments/2018-08-08-%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AE%89%E8%A3%85arch-linux-arm/</link><pubDate>Wed, 08 Aug 2018 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2018-08-08-%E5%9C%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E4%B8%8A%E5%AE%89%E8%A3%85arch-linux-arm/</guid><description>来自https://archlinuxarm.org/platforms/armv6/raspberry-pi
请将下面指令中的sdX替换为SD卡在您电脑中的设备名称。
使用fdisk为SD卡分区: # fdisk /dev/sdX 在fdisk的提示符中，删除原有的分区，然后新建分区： 按o，清除此设备上所有的分区； 按p来列出所有分区，当前设备应该没有任何分区存在； 按n，然后按p（主分区），然后按1（设备上第一个分区），然后按回车键接受默认的第一个扇区，然后为最后一个扇区输入+100M； 按t，然后按c设置第一个分区类型为W95 FAT32(LBA)； 按n，然后按p（主分区），按2（设备上第二个分区），然后按两次回车来接受默认的第一个和最后一个扇区； 按w，写入分区表后退出； 创建FAT文件系统并装载 # mkfs.vfat /dev/sdX1 # mkdir boot # mount /dev/sdX1 boot 创建ext4文件系统并装载: # mkfs.ext4 /dev/sdX2 # mkdir root # mount /dev/sdX2 root 下载系统镜像文件，并且提取到root文件系统（注，作为root用户，而不是通过sudo）: # wget http://os.archlinuxarm.org/os/ArchLinuxARM-rpi-latest.tar.gz # bsdtar -xpf ArchLinuxARM-rpi-latest.</description></item><item><title>Manjaro Linux访问iPhone需安装的工具</title><link>https://zenuo.github.io/fragments/2018-06-22-manjaro-linux%E8%AE%BF%E9%97%AEiphone%E9%9C%80%E5%AE%89%E8%A3%85%E7%9A%84%E5%B7%A5%E5%85%B7/</link><pubDate>Fri, 22 Jun 2018 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2018-06-22-manjaro-linux%E8%AE%BF%E9%97%AEiphone%E9%9C%80%E5%AE%89%E8%A3%85%E7%9A%84%E5%B7%A5%E5%85%B7/</guid><description>libimobiledevice简介 libimobiledevice是一个跨平台的软件库，可协议支持iPhone®，iPodTouch®，iPad®和AppleTV®设备。 与其他项目不同，它不依赖于使用任何现有的专有库并且不需要越狱。 它允许其他软件轻松访问设备的文件系统，检索有关设备及其内部的信息，备份/恢复设备，管理SpringBoard®图标，管理已安装的应用程序，检索地址簿/日历/笔记和书签以及（使用libgpod）同步音乐 和视频到设备。 该库自2007年8月开始开发，使Linux桌面支持这些设备。
以上摘自libimobiledevice项目官网
使用pacman安装 执行如下命令：
$ sudo pacman -Syy $ sudo pacman -S ifuse usbmuxd libplist libimobiledevice 参考 https://forum.manjaro.org/t/how-to-access-an-iphone-with-manjaro/3768/4 http://www.libimobiledevice.org/</description></item><item><title>MySQL查询某张表的列名</title><link>https://zenuo.github.io/fragments/2018-05-27-mysql%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%BC%A0%E8%A1%A8%E7%9A%84%E5%88%97%E5%90%8D/</link><pubDate>Sun, 27 May 2018 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2018-05-27-mysql%E6%9F%A5%E8%AF%A2%E6%9F%90%E5%BC%A0%E8%A1%A8%E7%9A%84%E5%88%97%E5%90%8D/</guid><description>查询列名，返回多列：
SELECTCOLUMN_NAMEFROM`information_schema`.`COLUMNS`WHERE`TABLE_SCHEMA`=&amp;#39;schema_name&amp;#39;ANDTABLE_NAME=&amp;#39;table_name&amp;#39;;查询列名，返回单列：
SELECTGROUP_CONCAT(COLUMN_NAMESEPARATOR&amp;#39;,&amp;#39;)FROM`information_schema`.`COLUMNS`WHERE`TABLE_SCHEMA`=&amp;#39;schema_name&amp;#39;ANDTABLE_NAME=&amp;#39;table_name&amp;#39;;参考 function_group-concat</description></item><item><title>MySQL的mysqldump例子</title><link>https://zenuo.github.io/fragments/2018-05-27-mysql%E7%9A%84mysqldump%E4%BE%8B%E5%AD%90/</link><pubDate>Sun, 27 May 2018 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2018-05-27-mysql%E7%9A%84mysqldump%E4%BE%8B%E5%AD%90/</guid><description>$ mysqldump \ --result-file=SQL_FILE_PATH \ --complete-insert SCHEMA_NAME [TABLE_NAME] \ -uYOUR_USERNAME \ -pYOUR_PASSWORD \ --host=HOST \ --port=PORT</description></item><item><title>快速排序C语言递归实现</title><link>https://zenuo.github.io/fragments/2017-11-09-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fc%E8%AF%AD%E8%A8%80%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</link><pubDate>Thu, 09 Nov 2017 19:23:13 +0800</pubDate><guid>https://zenuo.github.io/fragments/2017-11-09-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8Fc%E8%AF%AD%E8%A8%80%E9%80%92%E5%BD%92%E5%AE%9E%E7%8E%B0/</guid><description>#include&amp;lt;stdio.h&amp;gt; #include&amp;lt;stdlib.h&amp;gt; #define SIZE 10 void quick_sort(int a[], int lo, int hi) { if (lo &amp;lt; hi) { int i = partition(a, lo, hi); quick_sort(a, lo, i - 1); quick_sort(a, i + 1, hi); } } int partition(int a[], int lo, int hi) { int pivot, i, j, t; pivot = a[lo]; i = lo; j = hi + 1; while(1) { do ++i; while(a[i] &amp;lt;= pivot &amp;amp;&amp;amp; i &amp;lt;= hi); do --j; while(a[j] &amp;gt; pivot); if (i &amp;gt;= j) break; t = a[i], a[i] = a[j], a[j] = t; } t = a[lo], a[lo] = a[j], a[j] = t; return j; } int main(){ int array[SIZE] = {5, 4, 3, 1, -1, -3, 0, 10, 9, 8}; quick_sort(array, 0, SIZE - 1); int i; for(i = 0; i &amp;lt; SIZE; ++i) printf(&amp;quot;%d\n&amp;quot;, array[i]); return EXIT_SUCCESS; }</description></item></channel></rss>