<!doctype html><html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Linux的TCP backlog如何工作</title><meta name=generator content="Hugo 0.112.3"><link rel=stylesheet href="https://zenuo.github.io/css/styles.min.da6e1927bcb6a0faebcb06ab9925c87524b8057860afacf48eab54fcbf9eef18.css" integrity="sha256-2m4ZJ7y2oPrrywarmSXIdSS4BXhgr6z0jqtU/L+e7xg="><script async defer data-domain=kaiwern.com src=https://plausible.io/js/plausible.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Lora&family=Source+Sans+Pro:wght@400;600&display=swap" rel=stylesheet><body class="flex flex-col min-h-screen px-6 max-w-prose md:w-2/3 m-auto"><nav class=mt-8><ul id=nav-menu class="w-full flex items-center list-reset"><li><a href=https://zenuo.github.io/>Home</a></li><li><a href=https://zenuo.github.io/fragments/>Fragments</a></li><li><a href=https://zenuo.github.io/about/>Home</a></li><li><a href=https://zenuo.github.io/tags/>Tags</a></li></ul></nav><main class="flex-1 mt-10 sm:mt-12"><header class="mb-8 font-sans-serif"><div class="text-sm font-gray-700 mb-8"><p class="uppercase font-semibold"><a class=text-gray-700 href=/posts>posts</a></p><p>Nov 18, 2018</p></div><h1 class="title mb-2">Linux的TCP backlog如何工作</h1><p class="text-sm font-gray-700 mb-4 italic">Estimated Reading Time: 3 minutes (583 words)</p><div id=tags></div></header><article class="prose serif mb-12 text-gray-800"><blockquote><p>本文翻译自<a href=http://veithen.github.io/2014/01/01/how-tcp-backlog-works-in-linux.html>How TCP backlog works in Linux</a>。</p></blockquote><p>当某个应用程序使用<a href=http://linux.die.net/man/2/listen>listen系统调用</a>将一个socket置为<code>LISTEN</code>状态时，需要为这个socket设置参数<code>backlog</code>，该参数通常被描述为传入（incoming）连接队列的数量限制。</p><p><img src=/img/3d75825650e82a8afd29e773.png alt="TCP state diagram"></p><p>因为TCP使用三步握手（3-way handshake），在一个传入的连接在到达<code>ESTABLISHED</code>状态之前必须经过中间（intermediate）状态<code>SYN RECEIVED</code>，并且可由<a href=http://linux.die.net/man/2/accept>accept系统调用</a>返回到应用程序（请参阅上面复制的<a href=http://commons.wikimedia.org/wiki/File:Tcp_state_diagram_fixed.svg>TCP状态图</a>）。这意味着TCP/IP堆栈有两个选项来实现<code>LISTEN</code>状态的socket的积压队列（backlog queue）：</p><ol><li><p>使用大小由<code>listen系统调用</code>的<code>backlog</code>参数决定的单队列实现。当某个connection接收<code>SYN</code>分组时，它会发回<code>SYN/ACK</code>分组并将连接入列；当接收到相应的<code>ACK</code>分组时，连接将其状态改变为<code>ESTABLISHED</code>并且有资格切换到应用程序。也就是说，队列中包含两种不同状态——<code>SYN RECEIVED</code>和<code>ESTABLISHED</code>，只有后一种状态的connection才能通过<code>accept系统调用</code>返回给应用程序。</p></li><li><p>使用一个<code>SYN</code>队列（未完成的连接队列）和一个<code>accept</code>队列（已完成的连接队列）。状态<code>SYN RECEIVED</code>中的connection被添加到<code>SYN</code>队列中，并且当它们的状态变为<code>ESTABLISHED</code>时，即当接收到3次握手中的<code>ACK</code>分组时，移动到accept队列。顾名思义，<code>accept系统调用</code>然后只是为了消费（consume）来自accept队列的连接而实现。在这种情况下，<code>listen系统调用</code>的<code>backlog</code>参数确定accept队列的大小。</p></li></ol><p>从历史上看，BSD派生的TCP实现使用第一种选项，意味着当达到最大backlog时，系统将不再发回<code>SYN/ACK</code>分组以响应<code>SYN</code>分组。通常，TCP实现只会丢弃<code>SYN</code>分组（而不是响应<code>RST</code>分组），以便客户端重试。这是W. Richard Stevens的经典教材<a href=https://book.douban.com/subject/26790662/>TCP/IP详解 卷3</a>的第14.5节<code>listen Backlog Queue</code>描述的内容。</p><p>请注意，Stevens实际上解释了BSD实现确实使用了两个单独的队列，但它们表现为单个队列，其固定的最大大小由<code>backlog参数</code>确定（但不一定完全等于），即BSD在逻辑上表现如第一个选项所述：</p><blockquote><p>队列限制适用于[&mldr;]不完整连接队列上的条目数和[&mldr;]已完成连接队列[&mldr;]上的条目数之和。</p></blockquote><p>在Linux上，事情是不同的，如<code>listen系统调用</code>的<a href=http://linux.die.net/man/2/listen>手册页</a>中所述：</p><blockquote><p>Linux 2.2修改了TCP socket的<code>backlog</code>参数的行为。现在它指定了等待被accept的<code>完全</code>建立的套接字的队列长度，而不是<code>未完成</code>的连接请求的数量。可以在文件<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>中设置<code>未完成</code>的socket队列的长度。</p></blockquote><p>这意味着当前的Linux版本使用具有两个不同队列的第二个选项：具有由系统范围设置指定的大小的<code>SYN</code>队列和具有由应用程序指定的大小的accept队列。</p><p>现在有趣的问题是，如果接受队列已满并且需要将连接从SYN队列移动到接受队列，即当接收到3次握手的ACK分组时，这种实现如何表现。这种情况由<code>net/ipv4/tcp_minisocks.c</code>中的<code>tcp_check_req</code>函数处理，相关代码如下：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=n>child</span> <span class=o>=</span> <span class=nf>inet_csk</span><span class=p>(</span><span class=n>sk</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>icsk_af_ops</span><span class=o>-&gt;</span><span class=nf>syn_recv_sock</span><span class=p>(</span><span class=n>sk</span><span class=p>,</span> <span class=n>skb</span><span class=p>,</span> <span class=n>req</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=n>child</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>listen_overflow</span><span class=p>;</span>
</span></span></code></pre></div><p>对于IPv4，第一行代码实际调用<code>net/ipv4/tcp_ipv4.c</code>中的<code>tcp_v4_syn_recv_sock</code>函数，包含以下代码：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>sk_acceptq_is_full</span><span class=p>(</span><span class=n>sk</span><span class=p>))</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>exit_overflow</span><span class=p>;</span>
</span></span></code></pre></div><p>此处的代码对accept队列进行了check。<code>exit_overflow</code>标签之后的代码将执行一些清理，更新<code>/proc/net/netstat</code>中的<code>ListenOverflows</code>和<code>ListenDrops</code>统计信息，然后返回<code>NULL</code>。这将引发<code>tcp_check_req</code>函数中的<code>listen_overflow</code>代码的执行：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nl>listen_overflow</span><span class=p>:</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>sysctl_tcp_abort_on_overflow</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>                <span class=nf>inet_rsk</span><span class=p>(</span><span class=n>req</span><span class=p>)</span><span class=o>-&gt;</span><span class=n>acked</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>                <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span></code></pre></div><p>这意味着除非<code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>被置为<code>1</code>（在这种情况下，上面显示的代码之后的代码将发送一个<code>RST</code>分组），这种实现基本上不做处理。</p><p>总而言之，如果Linux中的TCP实现接收到3次握手的<code>ACK</code>分组并且accept队列已满，它将基本上忽略该分组。乍看起来很奇怪，但是别忘记有一个与<code>SYN RECEIVED</code>状态相关联的定时器：若没有收到<code>ACK</code>分组（或者如果它被忽略，如此处所考虑的情况），那么TCP实现将重新发送<code>SYN / ACK</code>分组（具有由<code>/proc/sys/net/ipv4/tcp_synack_retries</code>指定的重试次数，并使用<a href=http://en.wikipedia.org/wiki/Exponential_backoff>指数退避算法</a>）。</p><p>对于尝试连接（并发送数据）到达已达到其最大backlog的socket的客户端，可以在以下数据包跟踪中看到：</p><pre tabindex=0><code>0.000  127.0.0.1 -&gt; 127.0.0.1  TCP 74 53302 &gt; 9999 [SYN] Seq=0 Len=0
  0.000  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
  0.000  127.0.0.1 -&gt; 127.0.0.1  TCP 66 53302 &gt; 9999 [ACK] Seq=1 Ack=1 Len=0
  0.000  127.0.0.1 -&gt; 127.0.0.1  TCP 71 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
  0.207  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
  0.623  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
  1.199  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
  1.199  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 6#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
  1.455  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
  3.123  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
  3.399  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
  3.399  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 10#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
  6.459  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
  7.599  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
  7.599  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 13#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
 13.131  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
 15.599  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
 15.599  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 16#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
 26.491  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
 31.599  127.0.0.1 -&gt; 127.0.0.1  TCP 74 9999 &gt; 53302 [SYN, ACK] Seq=0 Ack=1 Len=0
 31.599  127.0.0.1 -&gt; 127.0.0.1  TCP 66 [TCP Dup ACK 19#1] 53302 &gt; 9999 [ACK] Seq=6 Ack=1 Len=0
 53.179  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
106.491  127.0.0.1 -&gt; 127.0.0.1  TCP 71 [TCP Retransmission] 53302 &gt; 9999 [PSH, ACK] Seq=1 Ack=1 Len=5
106.491  127.0.0.1 -&gt; 127.0.0.1  TCP 54 9999 &gt; 53302 [RST] Seq=1 Len=0
</code></pre><p>由于客户端上的TCP实现获得多个<code>SYN/ACK</code>分组，因此它将假设<code>ACK</code>分组丢失并重新发送（请参阅上面跟踪中带有<code>TCP Dup ACK</code>的行）。若服务器端的应用程序在达到最大<code>SYN/ACK</code>重试次数之前减少了backlog（即从accept队列中消费了一个entry），那么TCP实现最终将处理其中一个重复的<code>ACK</code>，转换状态从<code>SYN RECEIVED</code>到<code>ESTABLISHED</code>的connection，并将其添加到accept队列。否则，客户端最终将获得<code>RST</code>分组（如上面显示的示例）。</p><p>上述数据包跟踪还显示了此行为的另一个有趣方面。从客户端的角度来看，在接收到第一个<code>SYN/ACK</code>分组后，connection将处于<code>ESTABLISHED</code>状态。如果它发送数据（不先从服务器等待数据），那么也将重传该数据。幸运的是，<a href=http://en.wikipedia.org/wiki/Slow-start>TCP慢启动</a>应该限制在此阶段发送的段数（the number of segments sent）。</p><p>另一方面，如果客户端首先等待来自服务器的数据并且服务器永远不会减少backlog，那么最终结果是在客户端，连接处于<code>ESTABLISHED</code>状态，而在服务器端，connection被视为<code>CLOSED</code>。这意味着我们最终会建立<a href=http://en.wikipedia.org/wiki/Half-open_connection>半开连接</a>！</p><p>还有一个方面我们尚未讨论。来自<code>listen系统调用</code>的手册页的引用表明每个<code>SYN</code>分组都会导致一个connection被添加到<code>SYN</code>队列（除非该队列已满）。事实并非如此。原因在<code>net/ipv4/tcp_ipv4.c</code>的<code>tcp_v4_conn_request</code>方法（处理<code>SYN</code>分组）的如下代码中：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=cm>/* Accept backlog 已满。如果我们已经在`SYN`队列中排队了足够的热条目，则删除请求。它比使用指数增加超时的openreqs堵塞`SYN`队列更好。
</span></span></span><span class=line><span class=cl><span class=cm>*/</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=p>(</span><span class=nf>sk_acceptq_is_full</span><span class=p>(</span><span class=n>sk</span><span class=p>)</span> <span class=o>&amp;&amp;</span> <span class=nf>inet_csk_reqsk_queue_young</span><span class=p>(</span><span class=n>sk</span><span class=p>)</span> <span class=o>&gt;</span> <span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>NET_INC_STATS_BH</span><span class=p>(</span><span class=nf>sock_net</span><span class=p>(</span><span class=n>sk</span><span class=p>),</span> <span class=n>LINUX_MIB_LISTENOVERFLOWS</span><span class=p>);</span>
</span></span><span class=line><span class=cl>        <span class=k>goto</span> <span class=n>drop</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>这意味着若accept队列已满，则内核将对接受<code>SYN</code>分组的速率施加限制。若收到太多的<code>SYN</code>分组，其中一些将被丢弃。在这种情况下，由客户端重试发送<code>SYN</code>分组，我们最终得到的行为与BSD派生的实现相同。</p><p>最后，让我们试着了解为什么Linux的设计选择优于传统的BSD实现。Stevens提出以下有趣的观点：</p><blockquote><p>The backlog can be reached if the completed connection queue fills (i.e., the server process or the server host is so busy that the process cannot call accept fast enough to take the completed entries off the queue) or if the incomplete connection queue fills. The latter is the problem that HTTP servers face, when the round-trip time between the client and server is long, compared to the arrival rate of new connection requests, because a new SYN occupies an entry on this queue for one round-trip time. […]</p></blockquote><blockquote><p>The completed connection queue is almost always empty because when an entry is placed on this queue, the server’s call to accept returns, and the server takes the completed connection off the queue.</p></blockquote><p>Stevens建议的解决方案只是增加backlog。这样做的问题在于，它假定应用程序需要调整backlog，不仅要考虑它如何处理新建立的传入连接（incoming connection），还要考虑到诸如往返时间（round-trip time）等流量特性（traffic characteristics）的功能。Linux中的实现有效地区分了这两个问题：应用程序只负责调整backlog，以便它可以足够快地调用<code>accept系统调用</code>以避免填充accept队列），然后，系统管理员可以根据流量特征调整<code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>。</p></article></main><hr><footer class="w-full text-center p-4 pin-b text-xs text-gray-400"><p>made with <a href=https://gohugo.io class="underline hover:text-blue-400">Hugo</a> and <a href=https://tailwindcss.com class="underline hover:text-blue-400">TailwindCSS</a></p></footer></body></html>