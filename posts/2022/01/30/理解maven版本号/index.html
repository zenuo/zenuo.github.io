<!doctype html><html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>理解Maven版本号</title><meta name=generator content="Hugo 0.112.3"><link rel=stylesheet href="https://zenuo.github.io/css/styles.min.da6e1927bcb6a0faebcb06ab9925c87524b8057860afacf48eab54fcbf9eef18.css" integrity="sha256-2m4ZJ7y2oPrrywarmSXIdSS4BXhgr6z0jqtU/L+e7xg="><script async defer data-domain=kaiwern.com src=https://plausible.io/js/plausible.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Lora&family=Source+Sans+Pro:wght@400;600&display=swap" rel=stylesheet><body class="flex flex-col min-h-screen px-6 max-w-prose md:w-2/3 m-auto"><nav class=mt-8><ul id=nav-menu class="w-full flex items-center list-reset"><li><a href=https://zenuo.github.io/>Home</a></li><li><a href=https://zenuo.github.io/series/>Series</a></li><li><a href=https://zenuo.github.io/fragments/>Fragments</a></li><li><a href=https://zenuo.github.io/about/>About</a></li><li><a href=https://zenuo.github.io/tags/>Tags</a></li></ul></nav><main class="flex-1 mt-10 sm:mt-12"><header class="mb-8 font-sans-serif"><div class="text-sm font-gray-700 mb-8"><p class="uppercase font-semibold"><a class=text-gray-700 href=/posts>posts</a></p><p>Jan 30, 2022</p></div><h1 class="title mb-2">理解Maven版本号</h1><p class="text-sm font-gray-700 mb-4 italic">Estimated Reading Time: 1 minutes (117 words)</p><div id=tags></div></header><article class="prose serif mb-12 text-gray-800"><blockquote><p>来源<a href=https://docs.oracle.com/middleware/1212/core/MAVEN/maven_version.htm#MAVEN8855>Oracle® Fusion Middleware Developing Applications Using Continuous Integration</a></p></blockquote><p>在使用Maven时，理解如何使用版本号是非常重要的。一个经过深思熟虑（well thought out）的策略可以大大简化你的依赖管理工作量。本文介绍了关于版本号在Maven中如何工作的重要概念。</p><p>包含以下三个部分：</p><ul><li>Maven版本号如何工作</li><li>SNAPSHOT限定符</li><li>版本范围引用</li></ul><h2 id=1-maven版本号如何工作>1 Maven版本号如何工作</h2><p>Maven的版本管理方案（scheme）使用以下的标准：</p><ul><li>MajorVersion</li><li>MinorVersion</li><li>IncrementalVersion</li><li>BuildNumber</li><li>Qualifier</li></ul><p>例如：</p><ul><li>MajorVersion: 1.2.1</li><li>MinorVersion: 2.0</li><li>IncrementalVersion: 1.2-SNAPSHOT</li><li>BuildNumber: 1.4.2-12</li><li>Qualifier: 1.2-beta-2</li></ul><p>具有限定符的版本，旧于没有限定符的（发布版本），例如：<code>1.2-beta-2</code>旧于<code>1.2</code>。</p><p>带有不同限定符的相同版本，将会用基础的字符串比较，例如：<code>1.2-beta-2</code>新于<code>1.2-alpha-6</code>。</p><p>如果你在项目版本管理方案中没有遵循Maven的版本标准，那么对于版本比较，Maven将整个版本解释为一个简单的字符串。Maven及其核心插件将版本比较用于多项任务，最重要的是用于发布过程。</p><p>如果您使用非标准的版本管理方案，Maven发布和版本插件目标可能不会产生预期的结果。因为基本的字符串比较是在非标准的版本上进行的，所以在某些情况下，版本比较会错误地计算版本的顺序。</p><p>例如，Maven按以下顺序排列版本列表：</p><ul><li>1.0.1.0</li><li>1.0.10.1</li><li>1.0.10.2</li><li>1.0.9.3</li></ul><p>版本<code>1.0.9.3</code>应该在<code>1.0.10.1</code>和<code>1.0.10.2</code>之前，但意外的第四个字段（<code>.3</code>）迫使Maven将版本评估为一个字符串。</p><p>在Maven版本插件中可以看到这种对Maven影响的例子。Maven版本插件提供了以不同方式检查项目依赖关系的目标。其中一个有用的目标是<code>versions:dependency-updates-report</code>，它将检查项目的依赖层次，并报告哪些项目有较新的版本。当你在协调一个大型发布时，这个目标可以帮你找到依赖配置中的陈旧引用。如果Maven<strong>错误地</strong>识别了一个较新的版本，那么在插件中也会出现错误的报告。在前面的这个例子中，若你当前版本是<code>1.0.10.2</code>，那么这个插件将会将<code>1.0.9.3</code>报告成一个较新的版本。</p><p>如果你打算在你的依赖关系引用中使用版本范围，版本解析也是非常重要的。参见第3节，了解关于版本变化的信息。</p><h2 id=2-snapshot限定符>2 SNAPSHOT限定符</h2><p>Maven对待SNAPSHOT限定符的处理方式跟其他所有限定符不同。若一个版本号以<code>-SNAPSHOT</code>结尾，那么Maven会认为它是相关MajorVersion、MinorVersion或IncrementalVersion的 &ldquo;尚未发布 &ldquo;版本。</p><p>在一个持续集成环境中，SNAPSHOT版本在包成集成构建的最新性方面起着至关重要的作用，同时尽量减少每个集成步骤所需的重建量。</p><p>SNAPSHOP版本引用使依赖项目构建时能够获取SNAPSHOT依赖的最新部署实例。请注意，SNAPSHOT是不断变化的。每当代理部署工件时，它就会在共享仓库中更新。SHAPSHOT依赖被重新获取，在开发者的机器上，或者它在每个构建中被更新。这确保了依赖的更新和集成最新的变化，而不需要改项目中的依赖引用配置。</p><blockquote><p>试想，在开发过程中若不使用SNAPSHOT，则每次发布都需要在工件、使用工件方，至少两个工程中修改版本号，麻了😵‍💫</p></blockquote><p>通常，只有最近部署的SNAPSHOT，对于一个特定版本的工件在工件仓库中被保存。虽然仓库可以被配置为维护一个滚动归档，其中有一些特定工件的最新部署，但旧的实例通常只用于故障排除，在集成中不发挥任何作用。</p><p>持续构建服务器包括定义和执行基于Maven项目的作业的能力，如Hudson/Jenkins，可以配置为识别SNAPSHOT工件的更新，然后重建对更新工件有依赖性的项目。</p><h2 id=3-版本范围引用>3 版本范围引用</h2><p>Maven能指定可接受的版本范围作为依赖，下标显示了一系列的版本规格。</p><table><thead><tr><th style=text-align:center><strong>范围</strong></th><th style=text-align:center><strong>含义</strong></th></tr></thead><tbody><tr><td style=text-align:center>(,1.0]</td><td style=text-align:center>x &lt;= 1.0</td></tr><tr><td style=text-align:center>1.0</td><td style=text-align:center>如果1.0不可用，它通常意味着1.0或更高版本。不同的Maven插件可能对此有不同的解释，因此使用其他更具体的选项更为安全。</td></tr><tr><td style=text-align:center>[1.0]</td><td style=text-align:center>正是1.0</td></tr><tr><td style=text-align:center>[1.2,1.3]</td><td style=text-align:center>1.2 &lt;= x &lt;= 1.3</td></tr><tr><td style=text-align:center>[1.0,2.0)</td><td style=text-align:center>1.0 &lt;= x &lt; 2.0</td></tr><tr><td style=text-align:center>[1.5,)</td><td style=text-align:center>x >= 1.5</td></tr><tr><td style=text-align:center>(,1.0],[1.2,)</td><td style=text-align:center>x &lt;= 1.0 or x >= 1.2。多个集合用逗号隔开。</td></tr><tr><td style=text-align:center>(,1.1),(1.1,)</td><td style=text-align:center>如果已知1.1不能与库结合使用，这就排除了1.1</td></tr></tbody></table><p>当Maven遇到多个匹配的版本号时，它会使用最高匹配的版本。一般来说，版本引用应该根据需要来确定，这样Maven就可以酌情选择新的依赖版本，但也知道何时必须使用某个特定的版本。这试Maven能在跨依赖图的不同点桑指定不同版本的依赖时，选择最合适的版本。当发生这样的冲突时，Maven会从所有引用中选择最高版本。</p><p>鉴于可以选择使用版本范围，你可能会想，使用SNAPSHOT版本是否还有用。尽管你可以通过使用版本范围表达式达到一些相同的结果，但在持续构建系统中，SNAPSHOT的效果更好，原因如下：</p><ul><li>Maven工件仓库管理器处理SNAPSHOT比处理下一版本范围更有效。因为一个工件在一天内可以部署多次，所以存储库维护的独特实例的数量会迅速增加。</li><li>非SNAPSHOT发布版本是为了无限期地维护。如果你不断地发布新的版本并增加构建号或版本，存储需求很快就会变得无法管理。存储仓库管理器被设计为抛弃旧的SNAPSHOT，为新的实例腾出空间，因此所需的存储量保持不变。</li><li>SNAPSHOT也能被Maven和Maven的发布流程识别，这让你在进行发布构建时获得了一些好处。</li></ul><h2 id=4-参考>4 参考</h2><ul><li><a href=http://maven.apache.org/what-is-maven.html>What is Maven?</a></li><li><a href=http://www.maestrodev.com/better-builds-with-maven/about-this-guide/>Better Builds with Maven</a></li><li><a href=http://www.sonatype.org/maven>Maven By Example and Maven: The Complete Reference</a></li></ul></article></main><hr><footer class="w-full text-center p-4 pin-b text-xs text-gray-400"><p>made with <a href=https://gohugo.io class="underline hover:text-blue-400">Hugo</a> and <a href=https://tailwindcss.com class="underline hover:text-blue-400">TailwindCSS</a></p></footer></body></html>