<!doctype html><html><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>可扩展的事件多路复用：epoll与kqueue</title><meta name=generator content="Hugo 0.112.3"><link rel=stylesheet href="https://zenuo.github.io/css/styles.min.da6e1927bcb6a0faebcb06ab9925c87524b8057860afacf48eab54fcbf9eef18.css" integrity="sha256-2m4ZJ7y2oPrrywarmSXIdSS4BXhgr6z0jqtU/L+e7xg="><script async defer data-domain=kaiwern.com src=https://plausible.io/js/plausible.js></script>
<link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Lora&family=Source+Sans+Pro:wght@400;600&display=swap" rel=stylesheet><body class="flex flex-col min-h-screen px-6 max-w-prose md:w-2/3 m-auto"><nav class=mt-8><ul id=nav-menu class="w-full flex items-center list-reset"><li><a href=https://zenuo.github.io/>Home</a></li><li><a href=https://zenuo.github.io/series/>Series</a></li><li><a href=https://zenuo.github.io/fragments/>Fragments</a></li><li><a href=https://zenuo.github.io/about/>About</a></li><li><a href=https://zenuo.github.io/tags/>Tags</a></li></ul></nav><main class="flex-1 mt-10 sm:mt-12"><header class="mb-8 font-sans-serif"><div class="text-sm font-gray-700 mb-8"><p class="uppercase font-semibold"><a class=text-gray-700 href=/posts>posts</a></p><p>May 01, 2019</p></div><h1 class="title mb-2">可扩展的事件多路复用：epoll与kqueue</h1><p class="text-sm font-gray-700 mb-4 italic">Estimated Reading Time: 1 minutes (194 words)</p><div id=tags></div></header><article class="prose serif mb-12 text-gray-800"><blockquote><p>翻译自<a href=https://people.eecs.berkeley.edu/~sangjin/2012/12/21/epoll-vs-kqueue.html>Scalable Event Multiplexing: epoll vs. kqueue</a></p></blockquote><p>我比<code>BSD</code>更喜欢<code>Linux</code>，但我确实想在Linux中使用BSD的**<code>kqueue</code>**功能。</p><h2 id=什么是事件多路复用event-multiplexing>什么是事件多路复用（event multiplexing）</h2><p>假设您有一个简单的Web服务器，并且当前有两个打开的<strong>连接（套接字）</strong>。当服务器从任一连接收到HTTP请求时，它应该向客户端发送HTTP响应。但是你不知道两个客户端中的哪一个会先发送消息，何时发送消息。<strong><code>BSD Socket API</code><strong>的阻塞行为意味着如果在一个连接上调用</strong><code>recv()</code></strong>，您将无法响应另一个连接上的请求。这是您需要**I/O多路复用（I/O multiplexing）**的地方。</p><p>I/O复用的一种简单方法是<strong>为每个连接提供一个进程/线程</strong>，以便在一个连接中阻塞不会影响其他连接。通过这种方式，您可以有效地将所有<strong>毛茸茸</strong>的<strong>调度/多路复用问题</strong>委托给<strong>OS内核</strong>。这种多线程架构带来（可以说）高成本。维护大量线程对于内核来说并非易事。为每个连接设置单独的堆栈会增加内存占用，从而降低CPU**<code>缓存局部性（cache locality）</code>**。</p><p>如何在没有线程连接的情况下实现I / O复用？您可以使用<strong>非阻塞套接字操作</strong>为每个连接<strong>执行繁忙等待轮询</strong>，但这太浪费了。我们需要知道的是哪个套接字<strong>准备</strong>好了。因此，操作系统内核在您的<strong>应用程序</strong>和<strong>内核</strong>之间提供了一个单独的通道，此通道会在您的某些套接字准备就绪时<strong>通知</strong>。这就是**<code>select()/poll()</code><strong>的工作原理，基于</strong><code>就绪模型（readiness model）</code>**。</p><h2 id=回顾select>回顾：select()</h2><p>select()和poll()在它们的工作方式上非常相似。让我快速回顾一下select()的样子。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>select</span><span class=p>(</span><span class=kt>int</span> <span class=n>nfds</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>r</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>w</span><span class=p>,</span> <span class=n>fd_set</span> <span class=o>*</span><span class=n>e</span><span class=p>,</span> <span class=k>struct</span> <span class=n>timeval</span> <span class=o>*</span><span class=n>timeout</span><span class=p>)</span>
</span></span></code></pre></div><p>使用**<code>select()</code><strong>，您的应用程序需要提供</strong>三个兴趣集（interest sets）r，w和e**。每个集都表示为文件描述符的<strong>位图</strong>。例如，如果您对从<strong>文件描述符6</strong>中<strong>读取</strong>感兴趣，则将**<code>r</code><strong>的</strong>第六位<strong>设置为</strong><code>1</code><strong>。这个调用是阻塞的，直到感兴趣集中的</strong>一个或多个文件描述符<strong>准备就绪，这样您就可以对这些文件描述符执行</strong>没有阻塞的操作**。返回后，内核将<strong>覆盖位图</strong>以指定哪些文件描述符已<strong>准备就绪</strong>。</p><p>在可扩展性方面，我们可以找到四个问题：</p><ol><li>这些位图的大小是<strong>固定</strong>的（<strong><code>FD_SETSIZE</code></strong>，通常为**<code>1024</code>**）。但是，有一些方法可以解决这个限制。</li><li>由于位图被内核覆盖，用户应用程序应该为每个调用重新填充兴趣集。</li><li>用户应用程序和内核应扫描每个调用的整个位图，以确定哪些<strong>文件描述符</strong>属于<strong>兴趣集</strong>和<strong>结果集</strong>。这对于结果集来说尤其<strong>低效</strong>，因为它们可能非常<strong>稀疏</strong>（即，在给定时间只有少数文件描述符准备好）。</li><li>内核应迭代整个<strong>兴趣集</strong>，以找出哪些文件描述符<strong>已准备好</strong>，再次针对每个调用。如果它们都没有准备就绪，则内核再次迭代以为每个套接字注册内部事件处理程序。</li></ol><h2 id=回顾poll>回顾：poll()</h2><p>poll()旨在解决其中的一些问题。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=nf>poll</span><span class=p>(</span><span class=k>struct</span> <span class=n>pollfd</span> <span class=o>*</span><span class=n>fds</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nfds</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=n>pollfd</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>events</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>short</span> <span class=n>revents</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>**<code>poll()</code>**不依赖于位图，而是依赖于文件描述符数组（因此解决了问题＃1）。通过为感兴趣（事件）和结果（revents）提供单独的字段，如果用户应用程序正确维护并重新使用该数组，则问题＃2也会得到解决。如果轮询分离数组而不是字段，问题＃3可能已经修复。最后一个问题是固有的，不可避免的，因为select()和poll()都是无状态的；内核不会在内部维护兴趣集。</p><h2 id=为什么可扩展性很重要>为什么可扩展性很重要</h2><p>如果您的网络服务器需要维持相对较少的连接数（例如，几百个）并且连接速率很慢（再次，每秒100个连接），则select()或poll()就足够了。也许你甚至不需要打扰事件驱动的编程;坚持使用<strong>多进程/线程</strong>架构。如果性能不是您的首要考虑因素，那么编程的简易性和灵活性就是最重要的。 <code>Apache Web</code>服务器就是一个很好的例子。</p><p>但是，如果您的服务器应用程序是网络密集型的（例如，1000个并发连接和/或高连接速率），您应该对性能非常认真。这种情况通常被称为<a href=http://www.kegel.com/c10k.html><strong>c10k问题</strong></a>。使用select()或poll()，您的网络服务器几乎不会执行任何有用的操作，但会在如此高的负载下浪费宝贵的CPU周期。</p><p>假设有10000个并发连接。通常，只有<strong>少数</strong>文件描述符（例如10个）可以读取。对于每个select()/poll()调用，无理由地复制和扫描剩余的9990个文件描述符。</p><p>如前所述，这个问题来自于那些select()/poll()接口是<strong>无状态</strong>的。 Banga等人在<code>USENIX ATC 1999</code>上发表的<a href=http://static.usenix.org/event/usenix99/full_papers/banga/banga.pdf>论文</a>提出了一个新观点：有状态的兴趣集。内核不是为每个系统调用提供整个兴趣集，而是在<strong>内部</strong>维护兴趣集。在**<code>decalre_interest()</code><strong>调用时，内核会逐步更新兴趣集。用户应用程序通过</strong><code>get_next_event()</code>**从内核调度新事件。</p><p>受研究结果的启发，Linux和FreeBSD分别提出了他们自己的实现，epoll和kqueue。这意味着缺乏可移植性，因为基于epoll的应用程序无法在FreeBSD上运行。令人遗憾的是，kqueue在技术上优于epoll，因此没有充分理由证明epoll的存在。</p><h2 id=linux中的epoll>Linux中的epoll</h2><p>epoll接口包含三个系统调用：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_create</span><span class=p>(</span><span class=kt>int</span> <span class=n>size</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_ctl</span><span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=kt>int</span> <span class=n>op</span><span class=p>,</span> <span class=kt>int</span> <span class=n>fd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span><span class=n>event</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>epoll_wait</span><span class=p>(</span><span class=kt>int</span> <span class=n>epfd</span><span class=p>,</span> <span class=k>struct</span> <span class=n>epoll_event</span> <span class=o>*</span><span class=n>events</span><span class=p>,</span> <span class=kt>int</span> <span class=n>maxevents</span><span class=p>,</span> <span class=kt>int</span> <span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><p><strong><code>epoll_ctl()</code><strong>和</strong><code>epoll_wait()</code><strong>基本上分别对应于上面的</strong><code>decalre_interest()</code><strong>和</strong><code>get_next_event()</code></strong>。<strong><code>epoll_create()</code><strong>创建一个上下文作为文件描述符，而上面提到的文件隐含地假设每个进程上下文。在内部，Linux内核中的epoll实现与select()/poll()实现没有太大区别。唯一的区别是它是否有状态。这是因为它们的设计目标完全相同（套接字/管道的事件多路复用）。有关更多信息，请参阅Linux源代码树中的</strong><code>fs/select.c</code></strong>（用于select和poll）和**<code>fs/eventpoll.c</code>**（用于epoll）。</p><p>你也可以在epoll的<a href=http://lkml.indiana.edu/hypermail/linux/kernel/0010.3/0003.html>早期版本</a>中找到Linus Torvalds的一些初步想法。</p><h2 id=freebsd中的kqueue>FreeBSD中的kqueue</h2><p>与epoll一样，kqueue也支持每个进程的多个上下文（兴趣集）。 <strong><code>kqueue()</code><strong>执行与</strong><code>epoll_create()</code><strong>相同的操作。但是，</strong><code>kevent()</code><strong>调用使用</strong><code>kevent()</code><strong>集成了</strong><code>epoll_ctl()</code></strong>（调整兴趣集）和**<code>epoll_wait()</code>**（检索事件）的角色。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=kt>int</span> <span class=nf>kqueue</span><span class=p>(</span><span class=kt>void</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>kevent</span><span class=p>(</span><span class=kt>int</span> <span class=n>kq</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>kevent</span> <span class=o>*</span><span class=n>changelist</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nchanges</span><span class=p>,</span> 
</span></span><span class=line><span class=cl>           <span class=k>struct</span> <span class=n>kevent</span> <span class=o>*</span><span class=n>eventlist</span><span class=p>,</span> <span class=kt>int</span> <span class=n>nevents</span><span class=p>,</span> <span class=k>const</span> <span class=k>struct</span> <span class=n>timespec</span> <span class=o>*</span><span class=n>timeout</span><span class=p>);</span>
</span></span></code></pre></div><p>从编程的简易性来看，实际上kqueue比epoll复杂一点。这是因为kqueue以<strong>更抽象</strong>的方式设计，以实现<strong>通用性</strong>。让我们看一下**<code>struct kevent</code>**的外观。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=k>struct</span> <span class=n>kevent</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>     <span class=kt>uintptr_t</span>       <span class=n>ident</span><span class=p>;</span>          <span class=cm>/* identifier for this event */</span>
</span></span><span class=line><span class=cl>     <span class=kt>int16_t</span>         <span class=n>filter</span><span class=p>;</span>         <span class=cm>/* filter for event */</span>
</span></span><span class=line><span class=cl>     <span class=kt>uint16_t</span>        <span class=n>flags</span><span class=p>;</span>          <span class=cm>/* general flags */</span>
</span></span><span class=line><span class=cl>     <span class=kt>uint32_t</span>        <span class=n>fflags</span><span class=p>;</span>         <span class=cm>/* filter-specific flags */</span>
</span></span><span class=line><span class=cl>     <span class=kt>intptr_t</span>        <span class=n>data</span><span class=p>;</span>           <span class=cm>/* filter-specific data */</span>
</span></span><span class=line><span class=cl>     <span class=kt>void</span>            <span class=o>*</span><span class=n>udata</span><span class=p>;</span>         <span class=cm>/* opaque user data identifier */</span>
</span></span><span class=line><span class=cl> <span class=p>};</span>
</span></span></code></pre></div><p>虽然这些字段的详细信息超出了本文的范围，但您可能已经注意到没有明确的文件描述符字段。这是因为kqueue<strong>不仅仅</strong>被设计为用于套接字事件多路复用的select()/poll()的替代，而是作为各种类型的操作系统事件的<strong>一般机制</strong>。</p><p><strong><code>filter</code><strong>字段指定内核事件的</strong>类型</strong>。如果它是**<code>EVFILT_READ</code><strong>或</strong><code>EVFILT_WRITE</code><strong>，则kqueue的工作方式类似于epoll。在这种情况下，</strong><code>ident</code><strong>字段表示文件描述符。</strong><code>ident</code><strong>字段可以表示其他类型的标识符，例如</strong><code>进程ID</code><strong>和</strong>信号编号**，这取决于<strong>过滤器类型</strong>。详细信息可以在<a href="http://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">手册页</a>或<a href=http://people.freebsd.org/~jlemon/papers/kqueue.pdf>论文</a>中找到。</p><h2 id=epoll和kqueue的比较>epoll和kqueue的比较</h2><h3 id=性能>性能</h3><p>在性能方面，epoll设计有一个缺点；它不支持<strong>单个系统调用中的兴趣集的多个更新</strong>。当您有100个文件描述符来更新其在兴趣集中的状态时，您必须进行100次**<code>epoll_ctl()</code><strong>调用。如文章所述，过度系统调用导致的性能下降非常显着。我猜这是Banga等人原创作品的遗产，因为</strong><code>declare_interest()</code><strong>也只支持每次调用的一次更新。相反，您可以在单个</strong><code>kevent()</code>**调用中指定多个兴趣更新。</p><h3 id=非文件支持>非文件支持</h3><p>在我看来，另一个更重要的问题是epoll的范围有限。因为它旨在提高**select()/poll()**的性能，但仅此而已，epoll仅适用于文件描述符。这有什么问题？</p><p>经常引用“在Unix中，一切都是文件”。这大多是真的，但并非总是如此。例如，计时器不是文件。信号不是文件。信号量不是文件。进程不是文件。（在Linux中，）网络设备不是文件。类UNIX操作系统中有许多不是文件的东西。您不能使用**<code>select()/ poll()/epoll()</code><strong>来复制那些“事物”。除套接字外，典型的网络服务器还管理</strong>各种类型<strong>的资源。您可能希望使用单一，统一的界面监控它们，但您不能。要解决此问题，Linux支持许多补充系统调用，例如</strong><code>signalfd()</code><strong>，</strong><code>eventfd()</code><strong>和</strong><code>timerfd_create()</code><strong>，它们将非文件资源转换为文件描述符，以便您可以将它们与</strong><code>epoll()</code>**复用。但这看起来并不优雅&mldr;&mldr;你真的想要为每种类型的资源进行专门的系统调用吗？</p><p>在**<code>kqueue</code><em><em>中，通用的</em><code>struct kevent</code>*结构支持各种</em><em>非文件事件</em>*。例如，您的应用程序可以在子进程退出时收到通知（使用**<code>filter = EVFILT_PROC</code><strong>，</strong><code>ident = pid</code><strong>和</strong><code>fflags = NOTE_EXIT</code>**）。即使当前内核版本不支持某些资源或事件类型，也会在未来的内核版本中对其进行扩展，而不会对API进行任何更改。</p><h2 id=磁盘文件支持>磁盘文件支持</h2><p>最后一个问题是epoll甚至不支持所有类型的文件描述符; <strong><code>select()/poll()/epoll()</code><strong>不适用于</strong>常规（磁盘）文件</strong>。这是因为epoll对准备模型有<strong>很强的假设</strong>；监视套接字的准备情况，以便套接字上的后续IO调用不会阻塞。但是，磁盘文件不适合此模型，因为它们总是准备就绪。</p><p>当数据<strong>未缓存</strong>在内存中时磁盘I/O<strong>阻塞</strong>，而不是因为客户端没有发送消息。对于磁盘文件，<strong>完成通知模型（completion notification model）<strong>适合。在此模型中，您只需对磁盘文件发出I/O操作，并在完成后收到通知。kqueue支持使用</strong><code>EVFILT_AIO</code><strong>过滤器类型的此方法，以及</strong><code>POSIX AIO</code><strong>函数，例如</strong><code>aio_read()</code></strong>。在Linux中，您应该简单地祈祷磁盘访问不会以<strong>高缓存命中率</strong>阻塞（在许多网络服务器中非常常见），或者具有单独的线程以便<strong>磁盘I/O阻塞</strong>不会影响<strong>网络套接字</strong>处理（例如，<a href=http://www.cs.princeton.edu/~vivek/pubs/flash_usenix_99/flash.pdf>FLASH</a>体系结构） ）。</p><p>在我们之前的<a href=http://www.eecs.berkeley.edu/~sangjin/static/pub/osdi2012_megapipe.pdf>MegaPipe论文</a>中，我们提出了一个新的编程接口，它完全基于完成通知模型，适用于磁盘和非磁盘文件。</p></article></main><hr><footer class="w-full text-center p-4 pin-b text-xs text-gray-400"><p>made with <a href=https://gohugo.io class="underline hover:text-blue-400">Hugo</a> and <a href=https://tailwindcss.com class="underline hover:text-blue-400">TailwindCSS</a></p></footer></body></html>